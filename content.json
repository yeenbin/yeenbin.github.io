{"meta":{"title":"叶恩宾的博客","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-12-02T06:50:59.988Z","updated":"2019-10-30T02:45:53.164Z","comments":true,"path":"README.rst.html","permalink":"http://yoursite.com/README.rst.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-10-30T02:22:27.219Z","updated":"2019-10-30T02:22:27.219Z","comments":true,"path":"2019/10/30/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"iOS核心动画高级技巧","slug":"iOS核心动画高级技巧","date":"2019-09-03T07:05:00.000Z","updated":"2019-09-05T09:44:20.900Z","comments":true,"path":"2019/09/03/iOS核心动画高级技巧/","link":"","permalink":"http://yoursite.com/2019/09/03/iOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/","excerpt":"","text":"一个视图只有一个相关联的图层(自动创建)，同时它也可以支持添加无数多个子图层， 使用图层关联的视图而不是CALayer的好处在于，你能再使用所有CALayer底层特性的同时，也可以使用UIView的高级API(比如自动排版，布局和事件处理)。 当满足以下条件的时候，你可能更需要使用CALayer而不是UIView 开发同时可以在Mac OS上运行的跨平台应用 使用多种CALayer的子类，并且不想创建额外的UIView去包封装它们所有 做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著额不同(尽管如此，你可能会直接想使用OPenGL绘图) 寄宿图寄宿图：CALayer的寄宿图(即图层中包含的图)。 CALayer有一个属性叫做Contents，赋值的类型为CGImageRef，它是一个指向CGImage结构的指针。 UIImage有一个CGImage属性，它返回一个”CGImageRef”，直接赋值给contents会出现编译错误。需要通过bridged关键字转换。 1layer.contents = (__bridge id)imae.CGImage; contentGravity对应UIImageView的contentMode属性 12345678910111213141516171819202122232425262728typedef NSString * CALayerContentsGravity NS_STRING_ENUM;/** Layer `contentsGravity&apos; values. **/CA_EXTERN CALayerContentsGravity const kCAGravityCenter API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityTop API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityBottom API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityLeft API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityRight API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityTopLeft API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityTopRight API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityBottomLeft API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityBottomRight API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityResize API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityResizeAspect API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));CA_EXTERN CALayerContentsGravity const kCAGravityResizeAspectFill API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); 1self.layerView.layer.contentsGravity = kCAGravityResizeAspect; contentsScalecontentsScale属性其实属于支持高分辨率屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度(假设并没有设置contentsGravity属性)。UIView有一个类似功能但是非常少用到的contentScaleFactor属性。 ​ 如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们所熟知的Retain屏幕。 当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retain设备上就显示得不正确啦。 1layer.contentsScale = [UIScreen mainScreen].scale; maskToBoundsUIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds, 把它设置为YES。 contentRectCALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比contentsGravity灵活多了。 Custom Drawing12345678910111213141516171819202122232425262728293031@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CALayer *blueLayer = [CALayer layer]; blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f); blueLayer.backgroundColor = [UIColor blueColor].CGColor; // 把控制器当做layer的代理 blueLayer.delegate = self; blueLayer.contentsScale = [UIScreen mainScreen].scale; [self.layerView.layer addSublayer:blueLayer]; // 显示调用 display [blueLayer display]; // layer的宿寄图contents self.layerView.layer.contents = (__bridge id)[UIImage imageNamed:@&quot;snowman.jpg&quot;].CGImage; // 设置contentsGravity（类似UIImage的contentMode）这边是字符串枚举 self.layerView.layer.contentsGravity = kCAGravityResizeAspect; &#125;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx &#123; // 画一个厚厚的红色圆圈 CGContextSetLineWidth(ctx, 10.0f); CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor); CGContextStrokeEllipseInRect(ctx, layer.bounds);&#125;@end 实现CALayerDelegate来绘制图层 我们在blueLayer上显示地调用了 -display。 不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。 尽管我们没有用masksToBounds属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。 除非你穿件了饿一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个-displayer：的实现，那所有的问题就都没了。 ​ 当使用寄宿了视图的图层的时候，你也不必实现-displayLayer：和-drawLayer：inContext:方法来绘制你的寄宿图。通常做法是实现UIView的-drawRect：方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。 Hit TestingCALayer 并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一些列的方法帮你处理事件： -containsPoint: 和 -hitTest: 。 1234567891011121314151617 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 获取触摸的点 CGPoint point = [[touches anyObject] locationInView:self.view]; // 将点转化到白色图层的坐标系上 point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer]; // 用containsPoint：来判断触摸的点是否在图层上 if ([self.layerView.layer containsPoint:point]) &#123; // 将触摸的点转化到blueLayer的坐标系上 point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer]; if ([self.blueLayer containsPoint:point]) &#123; [[[UIAlertView alloc] initWithTitle:@&quot;在蓝色图层内&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil] show]; &#125;else &#123; [[[UIAlertView alloc] initWithTitle:@&quot;在白色图层内&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil] show]; &#125; &#125;&#125; -hitTest方法同样接受一个CGPoint类型参数，它返回图层本身，而不是BOOL类型。这意味着的不再需要像使用-containsPoint：哪一样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。 12345678910111213141516- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 2.用 -hitTest来判断触摸点是否在图层上 // 获取触摸的点 CGPoint point = [[touches anyObject] locationInView:self.view]; // 用hitTest：来判断触摸的点是否在图层上 CALayer *layer = [self.layerView.layer hitTest:point]; // 用hitTest：来判断触摸的点是否在图层上 if (layer == self.blueLayer) &#123; [[[UIAlertView alloc] initWithTitle:@&quot;在蓝色图层内&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil] show]; &#125;else if(layer == self.layerView.layer)&#123; [[[UIAlertView alloc] initWithTitle:@&quot;在白色图层内&quot; message:nil delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil, nil] show]; &#125;&#125; 自动布局当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraint API,但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate 如下函数： 1- (void)layoutSublayerOfLayer:(CALayer *)layer； 当图层的bounds发生改变，或者图层的-setNeedsLayout 方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子视图的大小。但是不能像UIView的autoresizingMask和 constraints属性做到应屏幕旋转。 这也是为甚最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。 视图效果圆角","categories":[],"tags":[]}]}